---
phase: 01-android-data-provider
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/android_provider/lib/providers/permission_provider.dart
  - apps/android_provider/lib/providers/extraction_provider.dart
  - apps/android_provider/lib/providers/sync_state_provider.dart
  - apps/android_provider/lib/services/contacts_service.dart
  - apps/android_provider/lib/services/sms_service.dart
  - apps/android_provider/lib/services/call_log_service.dart
  - apps/android_provider/lib/services/sync_storage_service.dart
  - apps/android_provider/lib/screens/home_screen.dart
  - apps/android_provider/lib/app.dart
autonomous: true

must_haves:
  truths:
    - "User can grant/deny permissions and app shows status per source"
    - "App shows count of extractable contacts with phone numbers"
    - "App shows count of extractable SMS messages"
    - "App shows count of extractable call log entries"
    - "App tracks last sync timestamp per data source"
    - "Permanently denied permissions show 'Open Settings' guidance"
  artifacts:
    - path: "apps/android_provider/lib/providers/permission_provider.dart"
      provides: "Permission state management"
      contains: "PermissionStatus"
    - path: "apps/android_provider/lib/services/contacts_service.dart"
      provides: "Contacts extraction with pagination"
      contains: "FlutterContacts"
    - path: "apps/android_provider/lib/services/sms_service.dart"
      provides: "SMS extraction with timestamp filtering"
      contains: "Telephony"
    - path: "apps/android_provider/lib/services/call_log_service.dart"
      provides: "Call log extraction with date filtering"
      contains: "CallLog.query"
    - path: "apps/android_provider/lib/screens/home_screen.dart"
      provides: "Main UI with counts and permission status"
      contains: "Consumer"
  key_links:
    - from: "apps/android_provider/lib/screens/home_screen.dart"
      to: "permission_provider.dart"
      via: "Riverpod ref.watch"
      pattern: "ref\\.watch\\(permission"
    - from: "apps/android_provider/lib/services/contacts_service.dart"
      to: "FlutterContacts.getContacts"
      via: "flutter_contacts package"
      pattern: "FlutterContacts\\.getContacts"
    - from: "apps/android_provider/lib/services/sms_service.dart"
      to: "Telephony.instance"
      via: "another_telephony package"
      pattern: "Telephony\\.instance"
    - from: "apps/android_provider/lib/services/call_log_service.dart"
      to: "CallLog.query"
      via: "call_log package"
      pattern: "CallLog\\.query"
    - from: "apps/android_provider/lib/services/sync_storage_service.dart"
      to: "SharedPreferences"
      via: "shared_preferences package"
      pattern: "SharedPreferences\\.getInstance"
---

<objective>
Implement permission handling, data extraction services for contacts/SMS/call logs with pagination and timestamp-based incremental sync, and main UI showing permission status and record counts.

Purpose: Complete the Android data provider functionality - extracting phone numbers from all three sources with incremental sync support.
Output: Functional Android app that can request permissions, extract data from granted sources, and display counts.
</objective>

<execution_context>
@/Users/jay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-android-data-provider/01-CONTEXT.md
@.planning/phases/01-android-data-provider/01-RESEARCH.md
@.planning/phases/01-android-data-provider/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Permission handling with Riverpod</name>
  <files>
    apps/android_provider/lib/providers/permission_provider.dart
  </files>
  <action>
Create apps/android_provider/lib/providers/permission_provider.dart:

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';

/// Permission status for all three data sources
class PermissionState {
  final PermissionStatus contacts;
  final PermissionStatus sms;
  final PermissionStatus callLog;
  final bool isLoading;
  final String? error;

  const PermissionState({
    this.contacts = PermissionStatus.denied,
    this.sms = PermissionStatus.denied,
    this.callLog = PermissionStatus.denied,
    this.isLoading = false,
    this.error,
  });

  bool get hasAnyGranted =>
      contacts.isGranted || sms.isGranted || callLog.isGranted;

  bool get allPermanentlyDenied =>
      contacts.isPermanentlyDenied &&
      sms.isPermanentlyDenied &&
      callLog.isPermanentlyDenied;

  List<String> get permanentlyDeniedNames => [
        if (contacts.isPermanentlyDenied) 'Contacts',
        if (sms.isPermanentlyDenied) 'SMS',
        if (callLog.isPermanentlyDenied) 'Call Log',
      ];

  PermissionState copyWith({
    PermissionStatus? contacts,
    PermissionStatus? sms,
    PermissionStatus? callLog,
    bool? isLoading,
    String? error,
  }) {
    return PermissionState(
      contacts: contacts ?? this.contacts,
      sms: sms ?? this.sms,
      callLog: callLog ?? this.callLog,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}

class PermissionNotifier extends StateNotifier<PermissionState> {
  PermissionNotifier() : super(const PermissionState());

  /// Check current permission status without requesting
  Future<void> checkPermissions() async {
    state = state.copyWith(isLoading: true);
    try {
      final contacts = await Permission.contacts.status;
      final sms = await Permission.sms.status;
      // Permission.phone covers call log on Android 9+
      final callLog = await Permission.phone.status;

      state = PermissionState(
        contacts: contacts,
        sms: sms,
        callLog: callLog,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Request all permissions at once (per CONTEXT.md decision)
  Future<void> requestAllPermissions() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final statuses = await [
        Permission.contacts,
        Permission.sms,
        Permission.phone, // Includes call log
      ].request();

      state = PermissionState(
        contacts: statuses[Permission.contacts] ?? PermissionStatus.denied,
        sms: statuses[Permission.sms] ?? PermissionStatus.denied,
        callLog: statuses[Permission.phone] ?? PermissionStatus.denied,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Open app settings for manually enabling permissions
  Future<bool> openSettings() async {
    return await openAppSettings();
  }
}

final permissionProvider =
    StateNotifierProvider<PermissionNotifier, PermissionState>(
  (ref) => PermissionNotifier(),
);
```

Key decisions from CONTEXT.md:
- Request all 3 permissions at once
- Partial grants OK - work with what's granted
- No explanation screen - directly show system dialogs
- Guide to settings if permanently denied
  </action>
  <verify>
    - File exists at apps/android_provider/lib/providers/permission_provider.dart
    - `flutter analyze apps/android_provider` passes
    - PermissionState has contacts, sms, callLog fields
    - requestAllPermissions requests all 3 at once
  </verify>
  <done>
    - Permission provider handles batch permission requests
    - Partial grant detection works
    - Permanently denied detection works with settings guidance
  </done>
</task>

<task type="auto">
  <name>Task 2: Data extraction services with pagination and timestamp sync</name>
  <files>
    apps/android_provider/lib/services/contacts_service.dart
    apps/android_provider/lib/services/sms_service.dart
    apps/android_provider/lib/services/call_log_service.dart
    apps/android_provider/lib/services/sync_storage_service.dart
    apps/android_provider/lib/providers/extraction_provider.dart
    apps/android_provider/lib/providers/sync_state_provider.dart
  </files>
  <action>
**1. Create sync_storage_service.dart** (timestamp persistence):

```dart
import 'package:shared_preferences/shared_preferences.dart';

enum DataSource { contacts, sms, callLog }

class SyncStorageService {
  static const _keyPrefix = 'last_sync_';

  Future<int?> getLastSyncTimestamp(DataSource source) async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt('$_keyPrefix${source.name}');
  }

  Future<void> setLastSyncTimestamp(DataSource source, int timestamp) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('$_keyPrefix${source.name}', timestamp);
  }

  Future<void> clearAllSyncState() async {
    final prefs = await SharedPreferences.getInstance();
    for (final source in DataSource.values) {
      await prefs.remove('$_keyPrefix${source.name}');
    }
  }
}
```

**2. Create contacts_service.dart** (from RESEARCH.md patterns):

```dart
import 'package:flutter_contacts/flutter_contacts.dart';

class ContactsService {
  static const int _pageSize = 500;

  /// Get count of contacts with phone numbers
  Future<int> getContactsWithPhonesCount() async {
    final contacts = await FlutterContacts.getContacts(
      withProperties: true,
      withPhoto: false,
    );
    return contacts.where((c) => c.phones.isNotEmpty).length;
  }

  /// Extract contacts with phone numbers, yielding in batches
  /// Note: flutter_contacts doesn't support timestamp filtering natively
  /// For contacts, we do full extraction (contacts change less frequently)
  Stream<List<Contact>> extractContacts({
    void Function(int current, int total)? onProgress,
  }) async* {
    final contacts = await FlutterContacts.getContacts(
      withProperties: true,
      withPhoto: false,
    );

    // Filter to contacts with phones
    final withPhones = contacts.where((c) => c.phones.isNotEmpty).toList();
    final total = withPhones.length;

    // Yield in batches to avoid memory pressure
    for (var i = 0; i < total; i += _pageSize) {
      final end = (i + _pageSize > total) ? total : i + _pageSize;
      final batch = withPhones.sublist(i, end);
      onProgress?.call(end, total);
      yield batch;
    }
  }

  /// Extract phone numbers from contacts
  Future<List<String>> extractPhoneNumbers() async {
    final contacts = await FlutterContacts.getContacts(
      withProperties: true,
      withPhoto: false,
    );

    final numbers = <String>[];
    for (final contact in contacts) {
      for (final phone in contact.phones) {
        numbers.add(phone.number);
      }
    }
    return numbers;
  }
}
```

**3. Create sms_service.dart** (from RESEARCH.md patterns):

```dart
import 'package:another_telephony/telephony.dart';

class SmsService {
  final Telephony _telephony = Telephony.instance;
  static const int _pageSize = 500;

  /// Get count of SMS messages (since timestamp if provided)
  Future<int> getSmsCount({int? sinceTimestamp}) async {
    final messages = await _getMessages(sinceTimestamp: sinceTimestamp);
    return messages.length;
  }

  /// Extract SMS messages with timestamp filtering
  Stream<List<SmsMessage>> extractSms({
    int? sinceTimestamp,
    void Function(int current, int total)? onProgress,
  }) async* {
    final messages = await _getMessages(sinceTimestamp: sinceTimestamp);
    final total = messages.length;

    for (var i = 0; i < total; i += _pageSize) {
      final end = (i + _pageSize > total) ? total : i + _pageSize;
      final batch = messages.sublist(i, end);
      onProgress?.call(end, total);
      yield batch;
    }
  }

  /// Get phone numbers from SMS messages
  Future<List<String>> extractPhoneNumbers({int? sinceTimestamp}) async {
    final messages = await _getMessages(sinceTimestamp: sinceTimestamp);
    return messages
        .map((m) => m.address)
        .where((addr) => addr != null)
        .cast<String>()
        .toList();
  }

  Future<List<SmsMessage>> _getMessages({int? sinceTimestamp}) async {
    SmsFilter? filter;
    if (sinceTimestamp != null) {
      filter = SmsFilter.where(SmsColumn.DATE)
          .greaterThan(sinceTimestamp.toString());
    }

    final inbox = await _telephony.getInboxSms(
      columns: [SmsColumn.ADDRESS, SmsColumn.DATE],
      filter: filter,
      sortOrder: [OrderBy(SmsColumn.DATE, sort: Sort.DESC)],
    );

    final sent = await _telephony.getSentSms(
      columns: [SmsColumn.ADDRESS, SmsColumn.DATE],
      filter: filter,
      sortOrder: [OrderBy(SmsColumn.DATE, sort: Sort.DESC)],
    );

    return [...inbox, ...sent];
  }
}
```

**4. Create call_log_service.dart** (from RESEARCH.md patterns):

```dart
import 'package:call_log/call_log.dart';

class CallLogService {
  static const int _pageSize = 500;

  /// Get count of call log entries (since timestamp if provided)
  Future<int> getCallLogCount({int? sinceTimestamp}) async {
    final entries = await _getEntries(sinceTimestamp: sinceTimestamp);
    return entries.length;
  }

  /// Extract call log entries with date filtering
  Stream<List<CallLogEntry>> extractCallLogs({
    int? sinceTimestamp,
    void Function(int current, int total)? onProgress,
  }) async* {
    final entries = await _getEntries(sinceTimestamp: sinceTimestamp);
    final total = entries.length;

    for (var i = 0; i < total; i += _pageSize) {
      final end = (i + _pageSize > total) ? total : i + _pageSize;
      final batch = entries.sublist(i, end);
      onProgress?.call(end, total);
      yield batch;
    }
  }

  /// Get phone numbers from call log
  Future<List<String>> extractPhoneNumbers({int? sinceTimestamp}) async {
    final entries = await _getEntries(sinceTimestamp: sinceTimestamp);
    return entries
        .map((e) => e.number)
        .where((num) => num != null)
        .cast<String>()
        .toList();
  }

  Future<List<CallLogEntry>> _getEntries({int? sinceTimestamp}) async {
    final now = DateTime.now().millisecondsSinceEpoch;

    final entries = await CallLog.query(
      dateFrom: sinceTimestamp ?? 0,
      dateTo: now,
    );

    return entries.toList();
  }
}
```

**5. Create extraction_provider.dart** (state management):

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/contacts_service.dart';
import '../services/sms_service.dart';
import '../services/call_log_service.dart';
import '../services/sync_storage_service.dart';

class ExtractionState {
  final int contactCount;
  final int smsCount;
  final int callLogCount;
  final bool isLoading;
  final String? error;
  final double progress;
  final String? currentOperation;

  const ExtractionState({
    this.contactCount = 0,
    this.smsCount = 0,
    this.callLogCount = 0,
    this.isLoading = false,
    this.error,
    this.progress = 0.0,
    this.currentOperation,
  });

  int get totalCount => contactCount + smsCount + callLogCount;

  ExtractionState copyWith({
    int? contactCount,
    int? smsCount,
    int? callLogCount,
    bool? isLoading,
    String? error,
    double? progress,
    String? currentOperation,
  }) {
    return ExtractionState(
      contactCount: contactCount ?? this.contactCount,
      smsCount: smsCount ?? this.smsCount,
      callLogCount: callLogCount ?? this.callLogCount,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      progress: progress ?? this.progress,
      currentOperation: currentOperation,
    );
  }
}

class ExtractionNotifier extends StateNotifier<ExtractionState> {
  final ContactsService _contactsService;
  final SmsService _smsService;
  final CallLogService _callLogService;
  final SyncStorageService _syncStorage;

  ExtractionNotifier({
    ContactsService? contactsService,
    SmsService? smsService,
    CallLogService? callLogService,
    SyncStorageService? syncStorage,
  })  : _contactsService = contactsService ?? ContactsService(),
        _smsService = smsService ?? SmsService(),
        _callLogService = callLogService ?? CallLogService(),
        _syncStorage = syncStorage ?? SyncStorageService(),
        super(const ExtractionState());

  /// Refresh counts for all granted permissions
  Future<void> refreshCounts({
    required bool hasContacts,
    required bool hasSms,
    required bool hasCallLog,
  }) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      int contacts = 0;
      int sms = 0;
      int calls = 0;

      if (hasContacts) {
        contacts = await _contactsService.getContactsWithPhonesCount();
      }

      if (hasSms) {
        final lastSync = await _syncStorage.getLastSyncTimestamp(DataSource.sms);
        sms = await _smsService.getSmsCount(sinceTimestamp: lastSync);
      }

      if (hasCallLog) {
        final lastSync = await _syncStorage.getLastSyncTimestamp(DataSource.callLog);
        calls = await _callLogService.getCallLogCount(sinceTimestamp: lastSync);
      }

      state = ExtractionState(
        contactCount: contacts,
        smsCount: sms,
        callLogCount: calls,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  void setProgress(double progress, String operation) {
    state = state.copyWith(progress: progress, currentOperation: operation);
  }

  void setError(String error) {
    state = state.copyWith(error: error, isLoading: false);
  }
}

// Service providers
final contactsServiceProvider = Provider((ref) => ContactsService());
final smsServiceProvider = Provider((ref) => SmsService());
final callLogServiceProvider = Provider((ref) => CallLogService());
final syncStorageServiceProvider = Provider((ref) => SyncStorageService());

final extractionProvider =
    StateNotifierProvider<ExtractionNotifier, ExtractionState>(
  (ref) => ExtractionNotifier(
    contactsService: ref.watch(contactsServiceProvider),
    smsService: ref.watch(smsServiceProvider),
    callLogService: ref.watch(callLogServiceProvider),
    syncStorage: ref.watch(syncStorageServiceProvider),
  ),
);
```

**6. Create sync_state_provider.dart** (last sync timestamps):

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/sync_storage_service.dart';

class SyncState {
  final int? contactsLastSync;
  final int? smsLastSync;
  final int? callLogLastSync;

  const SyncState({
    this.contactsLastSync,
    this.smsLastSync,
    this.callLogLastSync,
  });

  bool get hasEverSynced =>
      contactsLastSync != null ||
      smsLastSync != null ||
      callLogLastSync != null;

  String formatLastSync(int? timestamp) {
    if (timestamp == null) return 'Never';
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} '
        '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }
}

class SyncStateNotifier extends StateNotifier<SyncState> {
  final SyncStorageService _storage;

  SyncStateNotifier(this._storage) : super(const SyncState());

  Future<void> loadSyncState() async {
    final contacts = await _storage.getLastSyncTimestamp(DataSource.contacts);
    final sms = await _storage.getLastSyncTimestamp(DataSource.sms);
    final callLog = await _storage.getLastSyncTimestamp(DataSource.callLog);

    state = SyncState(
      contactsLastSync: contacts,
      smsLastSync: sms,
      callLogLastSync: callLog,
    );
  }

  Future<void> updateSyncTimestamp(DataSource source, int timestamp) async {
    await _storage.setLastSyncTimestamp(source, timestamp);
    await loadSyncState();
  }

  Future<void> clearAllSyncState() async {
    await _storage.clearAllSyncState();
    state = const SyncState();
  }
}

final syncStateProvider =
    StateNotifierProvider<SyncStateNotifier, SyncState>((ref) {
  return SyncStateNotifier(ref.watch(syncStorageServiceProvider));
});
```
  </action>
  <verify>
    - All 6 files exist in apps/android_provider/lib/
    - `flutter analyze apps/android_provider` passes
    - Services use pagination (pageSize = 500)
    - Services support timestamp-based filtering
    - Providers properly depend on services
  </verify>
  <done>
    - ContactsService extracts contacts with phones, batched
    - SmsService extracts SMS with timestamp filter, batched
    - CallLogService extracts calls with date filter, batched
    - SyncStorageService persists timestamps per source
    - ExtractionNotifier manages counts and progress
    - SyncStateNotifier manages last sync timestamps
  </done>
</task>

<task type="auto">
  <name>Task 3: Home screen UI with permission status and counts</name>
  <files>
    apps/android_provider/lib/screens/home_screen.dart
    apps/android_provider/lib/app.dart
  </files>
  <action>
**1. Create home_screen.dart** (utilitarian status display per CONTEXT.md):

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import '../providers/permission_provider.dart';
import '../providers/extraction_provider.dart';
import '../providers/sync_state_provider.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  @override
  void initState() {
    super.initState();
    // Check permissions and load sync state on startup
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(permissionProvider.notifier).checkPermissions();
      ref.read(syncStateProvider.notifier).loadSyncState();
    });
  }

  @override
  Widget build(BuildContext context) {
    final permissions = ref.watch(permissionProvider);
    final extraction = ref.watch(extractionProvider);
    final syncState = ref.watch(syncStateProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('PhoneSync'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Permission Status Section
            _buildSectionHeader('Permission Status'),
            _buildPermissionRow('Contacts', permissions.contacts),
            _buildPermissionRow('SMS', permissions.sms),
            _buildPermissionRow('Call Log', permissions.callLog),

            if (permissions.permanentlyDeniedNames.isNotEmpty) ...[
              const SizedBox(height: 8),
              TextButton.icon(
                onPressed: () =>
                    ref.read(permissionProvider.notifier).openSettings(),
                icon: const Icon(Icons.settings),
                label: Text(
                  'Open Settings to enable: ${permissions.permanentlyDeniedNames.join(", ")}',
                ),
              ),
            ],

            const SizedBox(height: 16),

            // Request Permissions Button
            if (!permissions.hasAnyGranted && !permissions.isLoading)
              ElevatedButton.icon(
                onPressed: () async {
                  await ref
                      .read(permissionProvider.notifier)
                      .requestAllPermissions();
                  // Refresh counts after permissions granted
                  final newPerms = ref.read(permissionProvider);
                  await ref.read(extractionProvider.notifier).refreshCounts(
                        hasContacts: newPerms.contacts.isGranted,
                        hasSms: newPerms.sms.isGranted,
                        hasCallLog: newPerms.callLog.isGranted,
                      );
                },
                icon: const Icon(Icons.security),
                label: const Text('Request Permissions'),
              ),

            const SizedBox(height: 24),

            // Data Counts Section
            _buildSectionHeader('Available Data'),
            if (extraction.isLoading)
              const LinearProgressIndicator()
            else ...[
              _buildCountRow(
                'Contacts',
                permissions.contacts.isGranted ? extraction.contactCount : null,
                !permissions.contacts.isGranted,
              ),
              _buildCountRow(
                'SMS',
                permissions.sms.isGranted ? extraction.smsCount : null,
                !permissions.sms.isGranted,
              ),
              _buildCountRow(
                'Call Log',
                permissions.callLog.isGranted ? extraction.callLogCount : null,
                !permissions.callLog.isGranted,
              ),
              const Divider(),
              _buildCountRow('Total', extraction.totalCount, false),
            ],

            const SizedBox(height: 24),

            // Last Sync Section
            _buildSectionHeader('Sync Status'),
            Text('Contacts: ${syncState.formatLastSync(syncState.contactsLastSync)}'),
            Text('SMS: ${syncState.formatLastSync(syncState.smsLastSync)}'),
            Text('Call Log: ${syncState.formatLastSync(syncState.callLogLastSync)}'),

            const Spacer(),

            // Refresh Button
            if (permissions.hasAnyGranted)
              Center(
                child: ElevatedButton.icon(
                  onPressed: extraction.isLoading
                      ? null
                      : () => ref.read(extractionProvider.notifier).refreshCounts(
                            hasContacts: permissions.contacts.isGranted,
                            hasSms: permissions.sms.isGranted,
                            hasCallLog: permissions.callLog.isGranted,
                          ),
                  icon: const Icon(Icons.refresh),
                  label: const Text('Refresh Counts'),
                ),
              ),

            // Error display
            if (extraction.error != null || permissions.error != null)
              Padding(
                padding: const EdgeInsets.only(top: 16),
                child: Text(
                  extraction.error ?? permissions.error ?? '',
                  style: TextStyle(color: Theme.of(context).colorScheme.error),
                ),
              ),

            // Sync progress (shown when desktop is pulling)
            if (extraction.currentOperation != null) ...[
              const SizedBox(height: 16),
              Text('${extraction.currentOperation}: ${(extraction.progress * 100).toInt()}%'),
              LinearProgressIndicator(value: extraction.progress),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
      ),
    );
  }

  Widget _buildPermissionRow(String name, PermissionStatus status) {
    final color = status.isGranted
        ? Colors.green
        : status.isPermanentlyDenied
            ? Colors.red
            : Colors.orange;
    final icon = status.isGranted
        ? Icons.check_circle
        : status.isPermanentlyDenied
            ? Icons.block
            : Icons.warning;
    final label = status.isGranted
        ? 'Granted'
        : status.isPermanentlyDenied
            ? 'Denied (Settings)'
            : 'Not Granted';

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, color: color, size: 20),
          const SizedBox(width: 8),
          Text(name),
          const Spacer(),
          Text(label, style: TextStyle(color: color)),
        ],
      ),
    );
  }

  Widget _buildCountRow(String name, int? count, bool noPermission) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Text(name),
          const Spacer(),
          Text(
            noPermission ? 'N/A' : count?.toString() ?? '...',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: noPermission ? Colors.grey : null,
            ),
          ),
        ],
      ),
    );
  }
}
```

**2. Update app.dart** to use HomeScreen:

```dart
import 'package:flutter/material.dart';
import 'screens/home_screen.dart';

class PhoneSyncApp extends StatelessWidget {
  const PhoneSyncApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'PhoneSync',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}
```
  </action>
  <verify>
    - `flutter analyze apps/android_provider` passes
    - App builds: `flutter build apk --debug`
    - HomeScreen shows permission status, counts, and sync state sections
    - "Request Permissions" button visible when no permissions granted
    - "Open Settings" link visible when permissions permanently denied
  </verify>
  <done>
    - Home screen displays permission status per source
    - Home screen shows record counts per source
    - Home screen shows last sync timestamps
    - Refresh button updates counts
    - Settings guidance shown for permanently denied permissions
    - Error messages displayed when errors occur
  </done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# Code quality
flutter analyze apps/android_provider

# Build verification
cd apps/android_provider && flutter build apk --debug

# File structure check
ls -la apps/android_provider/lib/providers/
ls -la apps/android_provider/lib/services/
ls -la apps/android_provider/lib/screens/

# Key patterns present
grep -l "FlutterContacts.getContacts" apps/android_provider/lib/services/
grep -l "Telephony.instance" apps/android_provider/lib/services/
grep -l "CallLog.query" apps/android_provider/lib/services/
grep -l "ref.watch" apps/android_provider/lib/screens/home_screen.dart
```

Manual verification on device/emulator:
1. Launch app
2. See "Request Permissions" button
3. Grant some/all permissions
4. See counts update
5. Deny permission permanently, see Settings guidance
</verification>

<success_criteria>
1. App launches and shows permission status
2. Granting contacts permission shows contact count
3. Granting SMS permission shows SMS count
4. Granting call log permission shows call log count
5. Partial grants work (grant 2 of 3 = shows 2 counts)
6. Permanently denied permissions show "Open Settings" link
7. Refresh button updates counts
8. Last sync timestamps display (initially "Never")
9. No crashes on permission denial
10. Large datasets (if available) don't crash the app
</success_criteria>

<output>
After completion, create `.planning/phases/01-android-data-provider/01-02-SUMMARY.md`
</output>
